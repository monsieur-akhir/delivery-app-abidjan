{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport axios from \"axios\";\nimport { API_URL } from \"../config/environment\";\nvar RouteOptimizationService = function () {\n  function RouteOptimizationService() {\n    _classCallCheck(this, RouteOptimizationService);\n  }\n  return _createClass(RouteOptimizationService, null, [{\n    key: \"getTrafficHotspots\",\n    value: (function () {\n      var _getTrafficHotspots = _asyncToGenerator(function* () {\n        try {\n          var response = yield axios.get(API_URL + \"/api/traffic/hotspots\");\n          return response.data;\n        } catch (error) {\n          console.error(\"Error fetching traffic hotspots:\", error);\n          return [];\n        }\n      });\n      function getTrafficHotspots() {\n        return _getTrafficHotspots.apply(this, arguments);\n      }\n      return getTrafficHotspots;\n    }())\n  }, {\n    key: \"getOptimalRoute\",\n    value: (function () {\n      var _getOptimalRoute = _asyncToGenerator(function* (origin, destination, waypoints) {\n        try {\n          var response = yield axios.post(API_URL + \"/api/routes/optimize\", {\n            origin: origin,\n            destination: destination,\n            waypoints: waypoints || []\n          });\n          return response.data;\n        } catch (error) {\n          console.error(\"Error calculating optimal route:\", error);\n          throw new Error(\"Impossible de calculer l'itinéraire optimal\");\n        }\n      });\n      function getOptimalRoute(_x, _x2, _x3) {\n        return _getOptimalRoute.apply(this, arguments);\n      }\n      return getOptimalRoute;\n    }())\n  }, {\n    key: \"estimateDeliveryTime\",\n    value: (function () {\n      var _estimateDeliveryTime = _asyncToGenerator(function* (origin, destination, scheduledTime) {\n        try {\n          var response = yield axios.post(API_URL + \"/api/routes/estimate-time\", {\n            origin: origin,\n            destination: destination,\n            scheduledTime: scheduledTime ? scheduledTime.toISOString() : new Date().toISOString()\n          });\n          return response.data;\n        } catch (error) {\n          console.error(\"Error estimating delivery time:\", error);\n          throw new Error(\"Impossible d'estimer le temps de livraison\");\n        }\n      });\n      function estimateDeliveryTime(_x4, _x5, _x6) {\n        return _estimateDeliveryTime.apply(this, arguments);\n      }\n      return estimateDeliveryTime;\n    }())\n  }, {\n    key: \"suggestDeliveryTime\",\n    value: (function () {\n      var _suggestDeliveryTime = _asyncToGenerator(function* (origin, destination) {\n        try {\n          var response = yield axios.post(API_URL + \"/api/routes/suggest-time\", {\n            origin: origin,\n            destination: destination\n          });\n          return response.data;\n        } catch (error) {\n          console.error(\"Error suggesting delivery time:\", error);\n          throw new Error(\"Impossible de suggérer un horaire de livraison\");\n        }\n      });\n      function suggestDeliveryTime(_x7, _x8) {\n        return _suggestDeliveryTime.apply(this, arguments);\n      }\n      return suggestDeliveryTime;\n    }())\n  }, {\n    key: \"optimizeDeliveryOrder\",\n    value: (function () {\n      var _optimizeDeliveryOrder = _asyncToGenerator(function* (startPoint, deliveryPoints) {\n        try {\n          var response = yield axios.post(API_URL + \"/api/routes/optimize-order\", {\n            startPoint: startPoint,\n            deliveryPoints: deliveryPoints\n          });\n          return response.data;\n        } catch (error) {\n          console.error(\"Error optimizing delivery order:\", error);\n          throw new Error(\"Impossible d'optimiser l'ordre des livraisons\");\n        }\n      });\n      function optimizeDeliveryOrder(_x9, _x0) {\n        return _optimizeDeliveryOrder.apply(this, arguments);\n      }\n      return optimizeDeliveryOrder;\n    }())\n  }]);\n}();\nexport default RouteOptimizationService;","map":{"version":3,"names":["axios","API_URL","RouteOptimizationService","_classCallCheck","_createClass","key","value","_getTrafficHotspots","_asyncToGenerator","response","get","data","error","console","getTrafficHotspots","apply","arguments","_getOptimalRoute","origin","destination","waypoints","post","Error","getOptimalRoute","_x","_x2","_x3","_estimateDeliveryTime","scheduledTime","toISOString","Date","estimateDeliveryTime","_x4","_x5","_x6","_suggestDeliveryTime","suggestDeliveryTime","_x7","_x8","_optimizeDeliveryOrder","startPoint","deliveryPoints","optimizeDeliveryOrder","_x9","_x0"],"sources":["/home/runner/workspace/mobile/services/RouteOptimizationService.ts"],"sourcesContent":["import axios from \"axios\"\nimport { API_URL } from \"../config/environment\"\nimport type { Coordinates } from \"../types/models\"\n\ninterface TrafficHotspot {\n  coordinates: Coordinates\n  intensity: number\n}\n\ninterface RouteResponse {\n  route: Coordinates[]\n  distance: number\n  duration: number\n  trafficDelay: number\n}\n\nclass RouteOptimizationService {\n  /**\n   * Récupère les points chauds de trafic dans la zone d'Abidjan\n   */\n  static async getTrafficHotspots(): Promise<TrafficHotspot[]> {\n    try {\n      const response = await axios.get(`${API_URL}/api/traffic/hotspots`)\n      return response.data\n    } catch (error) {\n      console.error(\"Error fetching traffic hotspots:\", error)\n      return []\n    }\n  }\n\n  /**\n   * Calcule l'itinéraire optimal entre deux points en tenant compte du trafic\n   */\n  static async getOptimalRoute(\n    origin: Coordinates,\n    destination: Coordinates,\n    waypoints?: Coordinates[],\n  ): Promise<RouteResponse> {\n    try {\n      const response = await axios.post(`${API_URL}/api/routes/optimize`, {\n        origin,\n        destination,\n        waypoints: waypoints || [],\n      })\n      return response.data\n    } catch (error) {\n      console.error(\"Error calculating optimal route:\", error)\n      throw new Error(\"Impossible de calculer l'itinéraire optimal\")\n    }\n  }\n\n  /**\n   * Estime le temps de livraison en fonction de l'heure de la journée et du trafic\n   */\n  static async estimateDeliveryTime(\n    origin: Coordinates,\n    destination: Coordinates,\n    scheduledTime?: Date,\n  ): Promise<{ duration: number; trafficDelay: number }> {\n    try {\n      const response = await axios.post(`${API_URL}/api/routes/estimate-time`, {\n        origin,\n        destination,\n        scheduledTime: scheduledTime ? scheduledTime.toISOString() : new Date().toISOString(),\n      })\n      return response.data\n    } catch (error) {\n      console.error(\"Error estimating delivery time:\", error)\n      throw new Error(\"Impossible d'estimer le temps de livraison\")\n    }\n  }\n\n  /**\n   * Suggère le meilleur moment pour effectuer une livraison\n   */\n  static async suggestDeliveryTime(\n    origin: Coordinates,\n    destination: Coordinates,\n  ): Promise<{ suggestedTime: string; estimatedDuration: number }> {\n    try {\n      const response = await axios.post(`${API_URL}/api/routes/suggest-time`, {\n        origin,\n        destination,\n      })\n      return response.data\n    } catch (error) {\n      console.error(\"Error suggesting delivery time:\", error)\n      throw new Error(\"Impossible de suggérer un horaire de livraison\")\n    }\n  }\n\n  /**\n   * Optimise l'ordre des livraisons pour un coursier\n   */\n  static async optimizeDeliveryOrder(\n    startPoint: Coordinates,\n    deliveryPoints: Array<{ id: string; coordinates: Coordinates }>,\n  ): Promise<{ order: string[]; route: Coordinates[]; totalDistance: number; totalDuration: number }> {\n    try {\n      const response = await axios.post(`${API_URL}/api/routes/optimize-order`, {\n        startPoint,\n        deliveryPoints,\n      })\n      return response.data\n    } catch (error) {\n      console.error(\"Error optimizing delivery order:\", error)\n      throw new Error(\"Impossible d'optimiser l'ordre des livraisons\")\n    }\n  }\n}\n\nexport default RouteOptimizationService\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}